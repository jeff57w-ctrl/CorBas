<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CorBas - Corpus Inspection Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.95;
        }

        .loading-notice {
            background: #fff3cd;
            border: 2px solid #ffc107;
            padding: 20px;
            margin: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .loading-notice h3 {
            color: #856404;
            margin-bottom: 10px;
        }

        .loading-notice p {
            color: #856404;
            line-height: 1.6;
        }

        .content {
            padding: 30px;
        }

        .tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 30px;
            border-bottom: 2px solid #e9ecef;
        }

        .tab {
            padding: 12px 24px;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 1em;
            color: #6c757d;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
            font-weight: 500;
        }

        .tab:hover {
            color: #667eea;
        }

        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .input-section {
            margin-bottom: 30px;
        }

        .input-section h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 1.3em;
        }

        textarea {
            width: 100%;
            min-height: 200px;
            padding: 15px;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            font-size: 1em;
            font-family: 'Courier New', monospace;
            resize: vertical;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .file-upload {
            border: 3px dashed #dee2e6;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #f8f9fa;
        }

        .file-upload:hover {
            border-color: #667eea;
            background: #e7f1ff;
        }

        .button {
            padding: 12px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: transform 0.2s;
            font-weight: 600;
            margin: 5px;
        }

        .button:hover {
            transform: translateY(-2px);
        }

        .button-secondary {
            background: #6c757d;
        }

        .corpus-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .corpus-item {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
            cursor: pointer;
            transition: all 0.3s;
        }

        .corpus-item:hover {
            background: #e7f1ff;
            transform: translateX(5px);
        }

        .corpus-item.active {
            background: #e7f1ff;
            border-left-width: 8px;
        }

        .analysis-output {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            max-height: 600px;
            overflow-y: auto;
        }

        .kwic-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 0.9em;
        }

        .kwic-table th {
            background: #667eea;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            position: sticky;
            top: 0;
        }

        .kwic-table td {
            padding: 10px;
            border-bottom: 1px solid #dee2e6;
        }

        .kwic-table tr:hover {
            background: #f8f9fa;
        }

        .left-context {
            text-align: right;
            color: #6c757d;
        }

        .node {
            font-weight: bold;
            color: #667eea;
            padding: 0 10px;
        }

        .right-context {
            color: #6c757d;
        }

        .tag {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            margin: 2px;
            font-family: monospace;
            font-weight: 500;
        }

        .tag-pos {
            background: #d4edda;
            color: #155724;
        }

        .tag-dep {
            background: #cce5ff;
            color: #004085;
        }

        .tag-sem {
            background: #fff3cd;
            color: #856404;
        }

        .search-box {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .search-box input, .search-box select {
            flex: 1;
            min-width: 200px;
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 1em;
        }

        .search-box input:focus, .search-box select:focus {
            outline: none;
            border-color: #667eea;
        }

        .svg-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            overflow-x: auto;
        }

        .freq-list {
            columns: 2;
            column-gap: 20px;
        }

        .freq-item {
            break-inside: avoid;
            padding: 10px;
            margin: 5px 0;
            background: white;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .freq-bar {
            height: 20px;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            border-radius: 3px;
            margin-top: 5px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-content h3 {
            margin-bottom: 20px;
        }

        .modal-content input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 2px solid #dee2e6;
            border-radius: 5px;
        }

        .token-display {
            display: inline-block;
            margin: 5px;
            padding: 8px 12px;
            background: white;
            border-radius: 5px;
            border: 1px solid #dee2e6;
            cursor: pointer;
            transition: all 0.2s;
        }

        .token-display:hover {
            background: #e7f1ff;
            border-color: #667eea;
        }

        .token-word {
            font-weight: bold;
            display: block;
            margin-bottom: 5px;
        }

        .processing-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .processing-overlay.show {
            display: flex;
        }

        .processing-content {
            background: white;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
        }

        .spinner-large {
            width: 60px;
            height: 60px;
            border: 6px solid #f3f3f3;
            border-top: 6px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8em;
            }
            
            .tabs {
                flex-direction: column;
            }

            .tab {
                width: 100%;
                text-align: left;
            }

            .corpus-list {
                grid-template-columns: 1fr;
            }

            .freq-list {
                columns: 1;
            }
        }

        .info-box {
            background: #e7f1ff;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .info-box h4 {
            color: #667eea;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üî¨ CorBas</h1>
            <p>Corpus Inspection Tool - University of Basra</p>
        </div>

        <div class="loading-notice">
            <h3>‚ö° Lightweight Version - Instant Loading!</h3>
            <p><strong>Note:</strong> This version uses built-in JavaScript NLP for instant loading. For full spaCy+PyMUSAS support, you'll need to set up a Python backend server. This version provides basic POS tagging, lemmatization, and all corpus analysis features with zero loading time!</p>
        </div>

        <div class="content">
            <div class="tabs">
                <button class="tab active" onclick="switchTab('input')">üìù Input</button>
                <button class="tab" onclick="switchTab('corpus')">üìö Corpus Manager</button>
                <button class="tab" onclick="switchTab('tokens')">üî§ Token View</button>
                <button class="tab" onclick="switchTab('concordance')">üîç Concordance</button>
                <button class="tab" onclick="switchTab('frequency')">üìä Frequency</button>
                <button class="tab" onclick="switchTab('collocation')">üîó Collocation</button>
                <button class="tab" onclick="switchTab('ngrams')">üìù N-grams</button>
            </div>

            <div id="input-tab" class="tab-content active">
                <div class="input-section">
                    <h3>Enter Text</h3>
                    <textarea id="textInput" placeholder="Paste or type your text here...">The cat sat on the mat. The dog ran in the park. Natural language processing is fascinating.</textarea>
                    <button class="button" onclick="processText()">üöÄ Process Text</button>
                </div>

                <div class="input-section">
                    <h3>Upload PDF File</h3>
                    <div class="file-upload" id="fileUpload" onclick="document.getElementById('pdfInput').click()">
                        <p>üìÑ Click or drag PDF file here</p>
                        <input type="file" id="pdfInput" accept=".pdf" style="display:none;" onchange="handlePDFUpload(event)">
                    </div>
                </div>

                <div class="input-section">
                    <h3>Or Try Sample Texts</h3>
                    <button class="button button-secondary" onclick="loadSample('academic')">üìö Academic Text</button>
                    <button class="button button-secondary" onclick="loadSample('news')">üì∞ News Article</button>
                    <button class="button button-secondary" onclick="loadSample('literature')">üìñ Literature</button>
                </div>
            </div>

            <div id="corpus-tab" class="tab-content">
                <h3>Your Corpora</h3>
                <button class="button button-secondary" onclick="clearAllCorpora()">üóëÔ∏è Clear All</button>
                <div class="corpus-list" id="corpusList">
                    <p style="color:#6c757d;">No corpora yet. Process some text to get started!</p>
                </div>
            </div>

            <div id="tokens-tab" class="tab-content">
                <h3>Token Analysis</h3>
                <div class="info-box">
                    <h4>üìä Token Information</h4>
                    <p>Click on any token to see detailed linguistic information including word form, lemma, and basic part-of-speech tagging.</p>
                </div>
                <div id="tokenDisplay" class="analysis-output"></div>
            </div>

            <div id="concordance-tab" class="tab-content">
                <h3>Concordance Search (KWIC)</h3>
                <div class="search-box">
                    <input type="text" id="kwicSearch" placeholder="Enter search term (supports regex)...">
                    <input type="number" id="kwicWindow" value="5" min="1" max="20" placeholder="Context window">
                    <button class="button" onclick="performKWIC()">üîç Search</button>
                    <button class="button button-secondary" onclick="exportResults('kwic')">üíæ Export CSV</button>
                </div>
                <div id="kwicResults" class="analysis-output"></div>
            </div>

            <div id="frequency-tab" class="tab-content">
                <h3>Word Frequency Analysis</h3>
                <div class="search-box">
                    <select id="freqType">
                        <option value="word">Word Forms</option>
                        <option value="lemma">Lemmas</option>
                        <option value="pos">POS Tags</option>
                    </select>
                    <input type="number" id="freqLimit" value="50" min="10" max="500" placeholder="Show top N">
                    <input type="number" id="minFreq" value="1" min="1" placeholder="Min frequency">
                </div>
                <button class="button" onclick="generateFrequency()">üìä Generate Frequency List</button>
                <button class="button button-secondary" onclick="exportResults('frequency')">üíæ Export CSV</button>
                <div id="frequencyResults" class="analysis-output"></div>
            </div>

            <div id="collocation-tab" class="tab-content">
                <h3>Collocation Analysis</h3>
                <div class="search-box">
                    <input type="text" id="collocSearch" placeholder="Enter node word...">
                    <input type="number" id="collocWindow" value="5" min="1" max="10" placeholder="Window size">
                    <input type="number" id="minCollocFreq" value="2" min="1" placeholder="Min frequency">
                    <button class="button" onclick="analyzeCollocations()">üîó Analyze</button>
                    <button class="button button-secondary" onclick="exportResults('collocation')">üíæ Export CSV</button>
                </div>
                <div id="collocationResults" class="analysis-output"></div>
                <div id="collocationNetwork" class="svg-container"></div>
            </div>

            <div id="ngrams-tab" class="tab-content">
                <h3>N-gram Analysis</h3>
                <div class="search-box">
                    <select id="ngramSize">
                        <option value="2">Bigrams (2-grams)</option>
                        <option value="3">Trigrams (3-grams)</option>
                        <option value="4">4-grams</option>
                        <option value="5">5-grams</option>
                    </select>
                    <input type="number" id="ngramLimit" value="30" min="10" max="100" placeholder="Show top N">
                    <button class="button" onclick="generateNgrams()">üìù Generate N-grams</button>
                    <button class="button button-secondary" onclick="exportResults('ngrams')">üíæ Export CSV</button>
                </div>
                <div id="ngramResults" class="analysis-output"></div>
            </div>
        </div>
    </div>

    <div id="corpusModal" class="modal">
        <div class="modal-content">
            <h3>Name Your Corpus</h3>
            <input type="text" id="corpusName" placeholder="Enter corpus name...">
            <div style="margin-top:20px;">
                <button class="button" onclick="saveCorpus()">Save</button>
                <button class="button button-secondary" onclick="closeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div id="tokenModal" class="modal">
        <div class="modal-content">
            <h3>Token Details</h3>
            <div id="tokenDetails"></div>
            <div style="margin-top:20px;">
                <button class="button" onclick="closeTokenModal()">Close</button>
            </div>
        </div>
    </div>

    <div id="processingOverlay" class="processing-overlay">
        <div class="processing-content">
            <div class="spinner-large"></div>
            <h3>Processing text...</h3>
            <p>Please wait</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        // Initialize
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        let corpora = JSON.parse(localStorage.getItem('corbas_corpora') || '[]');
        let currentCorpus = null;
        let processedData = null;

        // Basic NLP functions
        const POSTags = {
            'the': 'DET', 'a': 'DET', 'an': 'DET',
            'is': 'VERB', 'are': 'VERB', 'was': 'VERB', 'were': 'VERB', 'be': 'VERB',
            'have': 'VERB', 'has': 'VERB', 'had': 'VERB',
            'do': 'VERB', 'does': 'VERB', 'did': 'VERB',
            'in': 'ADP', 'on': 'ADP', 'at': 'ADP', 'to': 'ADP', 'for': 'ADP', 'with': 'ADP', 'by': 'ADP', 'from': 'ADP', 'of': 'ADP',
            'and': 'CCONJ', 'but': 'CCONJ', 'or': 'CCONJ',
            'i': 'PRON', 'you': 'PRON', 'he': 'PRON', 'she': 'PRON', 'it': 'PRON', 'we': 'PRON', 'they': 'PRON',
            'this': 'DET', 'that': 'DET', 'these': 'DET', 'those': 'DET',
            'not': 'ADV', 'very': 'ADV', 'well': 'ADV', 'also': 'ADV', 'just': 'ADV'
        };

        function basicPOSTag(word) {
            const lower = word.toLowerCase();
            if (POSTags[lower]) return POSTags[lower];
            if (word.endsWith('ly')) return 'ADV';
            if (word.endsWith('ing')) return 'VERB';
            if (word.endsWith('ed')) return 'VERB';
            if (word.endsWith('s') && word.length > 2) return 'NOUN';
            if (/^[A-Z]/.test(word)) return 'PROPN';
            if (/^\d+$/.test(word)) return 'NUM';
            return 'NOUN';
        }

        function basicLemmatize(word) {
            const lower = word.toLowerCase();
            if (lower.endsWith('ies')) return lower.slice(0, -3) + 'y';
            if (lower.endsWith('es')) return lower.slice(0, -2);
            if (lower.endsWith('s') && !lower.endsWith('ss')) return lower.slice(0, -1);
            if (lower.endsWith('ing') && lower.length > 4) return lower.slice(0, -3);
            if (lower.endsWith('ed') && lower.length > 3) return lower.slice(0, -2);
            return lower;
        }

        function tokenize(text) {
            const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];
            const tokens = [];
            let globalIndex = 0;

            sentences.forEach((sent, sentIdx) => {
                const words = sent.match(/\b[\w']+\b|[^\w\s]/g) || [];
                words.forEach((word, wordIdx) => {
                    if (word.trim()) {
                        tokens.push({
                            text: word,
                            lemma: basicLemmatize(word),
                            pos: basicPOSTag(word),
                            sentence: sentIdx,
                            index: globalIndex++
                        });
                    }
                });
            });

            return tokens;
        }

        function processText() {
            const text = document.getElementById('textInput').value.trim();
            if (!text) {
                alert('Please enter some text first!');
                return;
            }

            document.getElementById('processingOverlay').classList.add('show');

            setTimeout(() => {
                try {
                    const tokens = tokenize(text);
                    processedData = {
                        text: text,
                        tokens: tokens,
                        sentences: [...new Set(tokens.map(t => t.sentence))].length
                    };

                    document.getElementById('processingOverlay').classList.remove('show');
                    document.getElementById('corpusModal').classList.add('show');
                } catch (error) {
                    document.getElementById('processingOverlay').classList.remove('show');
                    alert('Error processing text: ' + error.message);
                }
            }, 500);
        }

        function saveCorpus() {
            const name = document.getElementById('corpusName').value.trim();
            if (!name) {
                alert('Please enter a corpus name!');
                return;
            }

            const corpus = {
                id: Date.now(),
                name: name,
                data: processedData,
                wordCount: processedData.tokens.length,
                sentences: processedData.sentences,
                created: new Date().toLocaleString()
            };

            corpora.push(corpus);
            currentCorpus = corpus;
            localStorage.setItem('corbas_corpora', JSON.stringify(corpora));

            updateCorpusList();
            displayTokens();
            closeModal();

            alert(`‚úÖ Corpus "${name}" saved!\n\n${corpus.wordCount} tokens processed\n${corpus.sentences} sentences detected`);
        }

        function closeModal() {
            document.getElementById('corpusModal').classList.remove('show');
            document.getElementById('corpusName').value = '';
        }

        function closeTokenModal() {
            document.getElementById('tokenModal').classList.remove('show');
        }

        function updateCorpusList() {
            const list = document.getElementById('corpusList');
            if (corpora.length === 0) {
                list.innerHTML = '<p style="color:#6c757d;">No corpora yet. Process some text to get started!</p>';
                return;
            }

            list.innerHTML = corpora.map(c => `
                <div class="corpus-item ${currentCorpus && currentCorpus.id === c.id ? 'active' : ''}" onclick="selectCorpus(${c.id})">
                    <h4>${c.name}</h4>
                    <p>üìù ${c.wordCount} tokens</p>
                    <p>üìÑ ${c.sentences} sentences</p>
                    <p>üïê ${c.created}</p>
                    <button class="button button-secondary" style="margin-top:10px;" onclick="event.stopPropagation(); deleteCorpus(${c.id})">üóëÔ∏è Delete</button>
                </div>
            `).join('');
        }

        function selectCorpus(id) {
            currentCorpus = corpora.find(c => c.id === id);
            updateCorpusList();
            displayTokens();
            alert('‚úÖ Selected corpus: ' + currentCorpus.name);
        }

        function deleteCorpus(id) {
            if (confirm('Are you sure you want to delete this corpus?')) {
                corpora = corpora.filter(c => c.id !== id);
                if (currentCorpus && currentCorpus.id === id) {
                    currentCorpus = corpora[0] || null;
                }
                localStorage.setItem('corbas_corpora', JSON.stringify(corpora));
                updateCorpusList();
            }
        }

        function clearAllCorpora() {
            if (confirm('Are you sure you want to delete ALL corpora?')) {
                corpora = [];
                currentCorpus = null;
                localStorage.setItem('corbas_corpora', JSON.stringify(corpora));
                updateCorpusList();
                document.getElementById('tokenDisplay').innerHTML = '';
            }
        }

        function displayTokens() {
            if (!currentCorpus) return;

            const container = document.getElementById('tokenDisplay');
            const tokens = currentCorpus.data.tokens;

            container.innerHTML = tokens.map((token, i) => `
                <div class="token-display" onclick="showTokenDetails(${i})">
                    <span class="token-word">${token.text}</span>
                    <span class="tag tag-pos">${token.pos}</span>
                </div>
            `).join('');
        }

        function showTokenDetails(index) {
            if (!currentCorpus) return;

            const token = currentCorpus.data.tokens[index];
            const details = `
                <table style="width:100%; border-collapse: collapse;">
                    <tr><td style="padding:8px; font-weight:bold;">Word:</td><td style="padding:8px;">${token.text}</td></tr>
                    <tr><td style="padding:8px; font-weight:bold;">Lemma:</td><td style="padding:8px;">${token.lemma}</td></tr>
                    <tr><td style="padding:8px; font-weight:bold;">POS Tag:</td><td style="padding:8px;"><span class="tag tag-pos">${token.pos}</span></td></tr>
                    <tr><td style="padding:8px; font-weight:bold;">Position:</td><td style="padding:8px;">${token.index + 1}</td></tr>
                    <tr><td style="padding:8px; font-weight:bold;">Sentence:</td><td style="padding:8px;">${token.sentence + 1}</td></tr>
                </table>
            `;

            document.getElementById('tokenDetails').innerHTML = details;
            document.getElementById('tokenModal').classList.add('show');
        }

        function performKWIC() {
            if (!currentCorpus) {
                alert('Please select a corpus first!');
                return;
            }

            const searchTerm = document.getElementById('kwicSearch').value.toLowerCase();
            const windowSize = parseInt(document.getElementById('kwicWindow').value) || 5;

            if (!searchTerm) {
                alert('Please enter a search term!');
                return;
            }

            const tokens = currentCorpus.data.tokens;
            const results = [];

            tokens.forEach((token, i) => {
                if (token.text.toLowerCase().includes(searchTerm) || token.lemma.includes(searchTerm)) {
                    const left = tokens.slice(Math.max(0, i - windowSize), i).map(t => t.text).join(' ');
                    const right = tokens.slice(i + 1, Math.min(tokens.length, i + windowSize + 1)).map(t => t.text).join(' ');

                    results.push({
                        num: results.length + 1,
                        corpus: currentCorpus.name,
                        left: left,
                        node: token.text,
                        right: right
                    });
                }
            });

            displayKWIC(results);
        }

        function displayKWIC(results) {
            const container = document.getElementById('kwicResults');

            if (results.length === 0) {
                container.innerHTML = '<p>No matches found.</p>';
                return;
            }

            const table = `
                <p><strong>Found ${results.length} matches</strong></p>
                <table class="kwic-table">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Corpus</th>
                            <th style="width:30%;">Left Context</th>
                            <th>Node</th>
                            <th style="width:30%;">Right Context</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${results.map(r => `
                            <tr>
                                <td>${r.num}</td>
                                <td>${r.corpus}</td>
                                <td class="left-context">${r.left}</td>
                                <td class="node">${r.node}</td>
                                <td class="right-context">${r.right}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;

            container.innerHTML = table;
            window.currentKWICResults = results;
        }

        function generateFrequency() {
            if (!currentCorpus) {
                alert('Please select a corpus first!');
                return;
            }

            const type = document.getElementById('freqType').value;
            const limit = parseInt(document.getElementById('freqLimit').value) || 50;
            const minFreq = parseInt(document.getElementById('minFreq').value) || 1;

            const tokens = currentCorpus.data.tokens;
            const freq = {};

            tokens.forEach(token => {
                let key;
                if (type === 'word') key = token.text.toLowerCase();
                else if (type === 'lemma') key = token.lemma;
                else if (type === 'pos') key = token.pos;

                freq[key] = (freq[key] || 0) + 1;
            });

            const sorted = Object.entries(freq)
                .filter(([word, count]) => count >= minFreq)
                .sort((a, b) => b[1] - a[1])
                .slice(0, limit);

            displayFrequency(sorted, type);
        }

        function displayFrequency(freq, type) {
            const container = document.getElementById('frequencyResults');
            const maxFreq = freq[0] ? freq[0][1] : 1;

            const html = `
                <p><strong>Top ${freq.length} ${type === 'word' ? 'words' : type === 'lemma' ? 'lemmas' : 'POS tags'}</strong></p>
                <div class="freq-list">
                    ${freq.map(([item, count], index) => {
                        const percentage = (count / maxFreq) * 100;
                        return `
                            <div class="freq-item">
                                <div style="flex:1;">
                                    <div style="display:flex; justify-content:space-between; align-items:center;">
                                        <span><strong>${index + 1}. ${item}</strong></span>
                                        <span style="color:#667eea; font-weight:bold;">${count}</span>
                                    </div>
                                    <div class="freq-bar" style="width:${percentage}%;"></div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;

            container.innerHTML = html;
            window.currentFreqResults = freq;
        }

        function analyzeCollocations() {
            if (!currentCorpus) {
                alert('Please select a corpus first!');
                return;
            }

            const nodeWord = document.getElementById('collocSearch').value.toLowerCase();
            const windowSize = parseInt(document.getElementById('collocWindow').value) || 5;
            const minFreq = parseInt(document.getElementById('minCollocFreq').value) || 2;

            if (!nodeWord) {
                alert('Please enter a node word!');
                return;
            }

            const tokens = currentCorpus.data.tokens;
            const collocates = {};

            tokens.forEach((token, i) => {
                if (token.text.toLowerCase() === nodeWord || token.lemma === nodeWord) {
                    const start = Math.max(0, i - windowSize);
                    const end = Math.min(tokens.length, i + windowSize + 1);

                    for (let j = start; j < end; j++) {
                        if (j !== i && tokens[j].text.length > 1) {
                            const word = tokens[j].text.toLowerCase();
                            collocates[word] = (collocates[word] || 0) + 1;
                        }
                    }
                }
            });

            const sorted = Object.entries(collocates)
                .filter(([word, count]) => count >= minFreq)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 30);

            if (sorted.length === 0) {
                document.getElementById('collocationResults').innerHTML = `<p>No collocations found for "${nodeWord}" with minimum frequency ${minFreq}.</p>`;
                return;
            }

            displayCollocations(nodeWord, sorted);
            drawCollocationNetwork(nodeWord, sorted);
        }

        function displayCollocations(node, collocates) {
            const container = document.getElementById('collocationResults');
            const maxFreq = collocates[0] ? collocates[0][1] : 1;

            const html = `
                <h4>Collocates of "${node}" (${collocates.length} found)</h4>
                <div class="freq-list">
                    ${collocates.map(([word, count], index) => {
                        const percentage = (count / maxFreq) * 100;
                        return `
                            <div class="freq-item">
                                <div style="flex:1;">
                                    <div style="display:flex; justify-content:space-between; align-items:center;">
                                        <span><strong>${index + 1}. ${word}</strong></span>
                                        <span style="color:#764ba2; font-weight:bold;">${count}</span>
                                    </div>
                                    <div class="freq-bar" style="width:${percentage}%; background:#764ba2;"></div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;

            container.innerHTML = html;
            window.currentCollocResults = { node, collocates };
        }

        function drawCollocationNetwork(node, collocates) {
            const container = document.getElementById('collocationNetwork');
            const width = Math.min(800, container.clientWidth || 600);
            const height = 500;
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) / 3;

            let svg = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">`;

            const maxFreq = collocates[0] ? collocates[0][1] : 1;

            collocates.forEach(([word, count], i) => {
                const angle = (i / collocates.length) * 2 * Math.PI - Math.PI / 2;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                const strokeWidth = Math.max(1, (count / maxFreq) * 5);

                svg += `<line x1="${centerX}" y1="${centerY}" x2="${x}" y2="${y}" stroke="#ccc" stroke-width="${strokeWidth}" opacity="0.6" />`;
            });

            svg += `<circle cx="${centerX}" cy="${centerY}" r="40" fill="#667eea" stroke="#fff" stroke-width="3" />`;
            svg += `<text x="${centerX}" y="${centerY}" text-anchor="middle" dy=".3em" fill="white" font-weight="bold" font-size="14">${node}</text>`;

            collocates.forEach(([word, count], i) => {
                const angle = (i / collocates.length) * 2 * Math.PI - Math.PI / 2;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                const nodeRadius = Math.max(20, Math.min(35, 15 + (count / maxFreq) * 20));

                svg += `<circle cx="${x}" cy="${y}" r="${nodeRadius}" fill="#764ba2" stroke="#fff" stroke-width="2" />`;
                svg += `<text x="${x}" y="${y}" text-anchor="middle" dy=".3em" fill="white" font-size="10" font-weight="bold">${word}</text>`;
                svg += `<text x="${x}" y="${y + nodeRadius + 15}" text-anchor="middle" fill="#666" font-size="10">${count}</text>`;
            });

            svg += `</svg>`;
            container.innerHTML = svg;
        }

        function generateNgrams() {
            if (!currentCorpus) {
                alert('Please select a corpus first!');
                return;
            }

            const n = parseInt(document.getElementById('ngramSize').value);
            const limit = parseInt(document.getElementById('ngramLimit').value) || 30;

            const tokens = currentCorpus.data.tokens.map(t => t.text.toLowerCase());
            const ngrams = {};

            for (let i = 0; i <= tokens.length - n; i++) {
                const ngram = tokens.slice(i, i + n).join(' ');
                ngrams[ngram] = (ngrams[ngram] || 0) + 1;
            }

            const sorted = Object.entries(ngrams)
                .sort((a, b) => b[1] - a[1])
                .slice(0, limit);

            displayNgrams(sorted, n);
        }

        function displayNgrams(ngrams, n) {
            const container = document.getElementById('ngramResults');
            const ngramName = n === 2 ? 'Bigrams' : n === 3 ? 'Trigrams' : `${n}-grams`;
            const maxFreq = ngrams[0] ? ngrams[0][1] : 1;

            const html = `
                <p><strong>Top ${ngrams.length} ${ngramName}</strong></p>
                <div class="freq-list">
                    ${ngrams.map(([ngram, count], index) => {
                        const percentage = (count / maxFreq) * 100;
                        return `
                            <div class="freq-item">
                                <div style="flex:1;">
                                    <div style="display:flex; justify-content:space-between; align-items:center;">
                                        <span><strong>${index + 1}. ${ngram}</strong></span>
                                        <span style="color:#667eea; font-weight:bold;">${count}</span>
                                    </div>
                                    <div class="freq-bar" style="width:${percentage}%;"></div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;

            container.innerHTML = html;
            window.currentNgramResults = ngrams;
        }

        function exportResults(type) {
            let data = '';
            let filename = '';

            switch(type) {
                case 'kwic':
                    if (!window.currentKWICResults) {
                        alert('No KWIC results to export!');
                        return;
                    }
                    data = 'Number,Corpus,Left Context,Node,Right Context\n';
                    window.currentKWICResults.forEach(r => {
                        data += `${r.num},"${r.corpus}","${r.left}","${r.node}","${r.right}"\n`;
                    });
                    filename = 'corbas_concordance.csv';
                    break;

                case 'frequency':
                    if (!window.currentFreqResults) {
                        alert('No frequency results to export!');
                        return;
                    }
                    data = 'Rank,Item,Frequency\n';
                    window.currentFreqResults.forEach(([item, count], index) => {
                        data += `${index + 1},"${item}",${count}\n`;
                    });
                    filename = 'corbas_frequency.csv';
                    break;

                case 'collocation':
                    if (!window.currentCollocResults) {
                        alert('No collocation results to export!');
                        return;
                    }
                    data = `Node Word: ${window.currentCollocResults.node}\n`;
                    data += 'Rank,Collocate,Frequency\n';
                    window.currentCollocResults.collocates.forEach(([word, count], index) => {
                        data += `${index + 1},"${word}",${count}\n`;
                    });
                    filename = 'corbas_collocations.csv';
                    break;

                case 'ngrams':
                    if (!window.currentNgramResults) {
                        alert('No n-gram results to export!');
                        return;
                    }
                    data = 'Rank,N-gram,Frequency\n';
                    window.currentNgramResults.forEach(([ngram, count], index) => {
                        data += `${index + 1},"${ngram}",${count}\n`;
                    });
                    filename = 'corbas_ngrams.csv';
                    break;
            }

            downloadFile(data, filename);
        }

        function downloadFile(content, filename) {
            const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');

            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(tabName + '-tab').classList.add('active');
        }

        async function handlePDFUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            document.getElementById('processingOverlay').classList.add('show');

            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;

                let fullText = '';

                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    fullText += pageText + '\n\n';
                }

                document.getElementById('textInput').value = fullText;
                document.getElementById('processingOverlay').classList.remove('show');
                alert(`‚úÖ PDF loaded! ${pdf.numPages} pages extracted.\n\nClick "Process Text" to analyze.`);

            } catch (error) {
                document.getElementById('processingOverlay').classList.remove('show');
                console.error('PDF error:', error);
                alert('Error loading PDF: ' + error.message);
            }
        }

        function loadSample(type) {
            const samples = {
                academic: "Natural language processing is a subfield of linguistics, computer science, and artificial intelligence concerned with the interactions between computers and human language. The goal is to enable computers to understand, interpret, and generate human language in a valuable way. Machine learning algorithms are increasingly used to analyze and process large amounts of natural language data.",
                news: "The University of Basra announced today a new initiative to promote digital literacy among students. The program will provide training in modern technologies and computational thinking. Faculty members expressed enthusiasm about the potential impact on student learning outcomes. The initiative is expected to launch next semester with support from the administration.",
                literature: "It was the best of times, it was the worst of times. The old man sat by the window, watching the rain fall gently on the ancient stones. His thoughts drifted back through the years, remembering faces long forgotten and words never spoken. Time moved slowly in this quiet corner of the world, where past and present seemed to merge into one continuous moment."
            };

            document.getElementById('textInput').value = samples[type];
            alert(`‚úÖ ${type.charAt(0).toUpperCase() + type.slice(1)} sample text loaded!\n\nClick "Process Text" to analyze.`);
        }

        const fileUpload = document.getElementById('fileUpload');

        fileUpload.addEventListener('dragover', (e) => {
            e.preventDefault();
            fileUpload.style.borderColor = '#667eea';
            fileUpload.style.background = '#e7f1ff';
        });

        fileUpload.addEventListener('dragleave', () => {
            fileUpload.style.borderColor = '#dee2e6';
            fileUpload.style.background = '#f8f9fa';
        });

        fileUpload.addEventListener('drop', (e) => {
            e.preventDefault();
            fileUpload.style.borderColor = '#dee2e6';
            fileUpload.style.background = '#f8f9fa';

            const file = e.dataTransfer.files[0];
            if (file && file.type === 'application/pdf') {
                document.getElementById('pdfInput').files = e.dataTransfer.files;
                handlePDFUpload({target: {files: [file]}});
            }
        });

        updateCorpusList();
        if (currentCorpus) displayTokens();
    </script>
</body>
</html>