<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CorBas - Corpus Inspection Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.95;
        }

        .content {
            padding: 30px;
        }

        .tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 30px;
            border-bottom: 2px solid #e9ecef;
        }

        .tab {
            padding: 12px 20px;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 0.95em;
            color: #6c757d;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
            font-weight: 500;
        }

        .tab:hover {
            color: #667eea;
        }

        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .input-section {
            margin-bottom: 30px;
        }

        .input-section h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 1.3em;
        }

        textarea {
            width: 100%;
            min-height: 200px;
            padding: 15px;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            font-size: 1em;
            font-family: 'Courier New', monospace;
            resize: vertical;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .file-upload {
            border: 3px dashed #dee2e6;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #f8f9fa;
        }

        .file-upload:hover {
            border-color: #667eea;
            background: #e7f1ff;
        }

        .button {
            padding: 12px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: transform 0.2s;
            font-weight: 600;
            margin: 5px;
        }

        .button:hover {
            transform: translateY(-2px);
        }

        .button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .button-secondary {
            background: #6c757d;
        }

        .button-success {
            background: #28a745;
        }

        .corpus-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .corpus-item {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
            cursor: pointer;
            transition: all 0.3s;
        }

        .corpus-item:hover {
            background: #e7f1ff;
            transform: translateX(5px);
        }

        .corpus-item.active {
            background: #e7f1ff;
            border-left-width: 8px;
        }

        .analysis-output {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            max-height: 600px;
            overflow-y: auto;
        }

        .kwic-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 0.9em;
        }

        .kwic-table th {
            background: #667eea;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .kwic-table td {
            padding: 10px;
            border-bottom: 1px solid #dee2e6;
        }

        .kwic-table tr:hover {
            background: #f8f9fa;
        }

        .left-context {
            text-align: right;
            color: #6c757d;
        }

        .node {
            font-weight: bold;
            color: #667eea;
            padding: 0 10px;
        }

        .right-context {
            color: #6c757d;
        }

        .tag {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            margin: 2px;
            font-family: monospace;
            font-weight: 500;
        }

        .tag-pos {
            background: #d4edda;
            color: #155724;
        }

        .search-box {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
            align-items: center;
        }

        .search-box input, .search-box select {
            flex: 1;
            min-width: 200px;
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 1em;
        }

        .search-box input:focus, .search-box select:focus {
            outline: none;
            border-color: #667eea;
        }

        .search-box label {
            font-weight: 500;
            color: #333;
        }

        .tag-helper {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .tag-helper h4 {
            color: #856404;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .tag-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .tag-button {
            padding: 8px 12px;
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9em;
            text-align: left;
        }

        .tag-button:hover {
            border-color: #667eea;
            background: #e7f1ff;
        }

        .tag-button strong {
            display: block;
            color: #667eea;
            font-size: 1.1em;
        }

        .tag-button small {
            color: #6c757d;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-content h3 {
            margin-bottom: 20px;
        }

        .modal-content input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 2px solid #dee2e6;
            border-radius: 5px;
        }

        .processing-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .processing-overlay.show {
            display: flex;
        }

        .processing-content {
            background: white;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            min-width: 300px;
        }

        .spinner-large {
            width: 60px;
            height: 60px;
            border: 6px solid #f3f3f3;
            border-top: 6px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e9ecef;
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .info-box {
            background: #e7f1ff;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
            text-align: center;
        }

        .stat-card h4 {
            font-size: 2em;
            color: #667eea;
            margin-bottom: 5px;
        }

        .stat-card p {
            color: #6c757d;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8em;
            }
            
            .tabs {
                flex-direction: column;
            }

            .tab {
                width: 100%;
                text-align: left;
            }

            .corpus-list {
                grid-template-columns: 1fr;
            }

            .tag-grid {
                grid-template-columns: 1fr;
            }

            .search-box {
                flex-direction: column;
            }

            .search-box input, .search-box select {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔬 CorBas Professional</h1>
            <p>Advanced Corpus Inspection Tool - University of Basra</p>
            <p style="font-size:0.9em; margin-top:10px;">✨ Optimized for large files (300+ pages) | Advanced POS/Semantic Search | Excel Export</p>
        </div>

        <div class="content">
            <div class="tabs">
                <button class="tab active" onclick="switchTab('input')">📝 Input</button>
                <button class="tab" onclick="switchTab('corpus')">📚 Corpus Manager</button>
                <button class="tab" onclick="switchTab('concordance')">🔍 Concordance</button>
                <button class="tab" onclick="switchTab('tagsearch')">🏷️ Advanced Tag Search</button>
                <button class="tab" onclick="switchTab('frequency')">📊 Frequency</button>
                <button class="tab" onclick="switchTab('collocation')">🔗 Collocation</button>
            </div>

            <!-- Input Tab -->
            <div id="input-tab" class="tab-content active">
                <div class="input-section">
                    <h3>Enter Text</h3>
                    <textarea id="textInput" placeholder="Paste or type your text here...">The cat sat on the mat. The dog ran in the park. Natural language processing is fascinating.</textarea>
                    <button class="button" onclick="processText()">🚀 Process Text</button>
                </div>

                <div class="input-section">
                    <h3>Upload Large PDF Files (up to 300+ pages)</h3>
                    <div class="file-upload" id="fileUpload" onclick="document.getElementById('pdfInput').click()">
                        <p>📄 Click or drag PDF file here</p>
                        <p style="font-size:0.9em; color:#6c757d; margin-top:10px;">Optimized for large academic papers and books</p>
                        <input type="file" id="pdfInput" accept=".pdf" style="display:none;" onchange="handlePDFUpload(event)">
                    </div>
                </div>
            </div>

            <!-- Corpus Manager Tab -->
            <div id="corpus-tab" class="tab-content">
                <h3>Your Corpora</h3>
                <div class="stats-grid" id="corpusStats"></div>
                <button class="button button-secondary" onclick="clearAllCorpora()">🗑️ Clear All</button>
                <div class="corpus-list" id="corpusList">
                    <p style="color:#6c757d;">No corpora yet. Process some text to get started!</p>
                </div>
            </div>

            <!-- Concordance Tab -->
            <div id="concordance-tab" class="tab-content">
                <h3>Concordance Search (KWIC)</h3>
                <div class="search-box">
                    <input type="text" id="kwicSearch" placeholder="Enter search term (supports regex)...">
                    <label>Context:</label>
                    <input type="number" id="kwicWindow" value="5" min="1" max="20" style="max-width:100px;">
                    <button class="button" onclick="performKWIC()">🔍 Search</button>
                    <button class="button button-success" onclick="exportToExcel('kwic')">📊 Export Excel</button>
                </div>
                <div id="kwicResults" class="analysis-output"></div>
            </div>

            <!-- Advanced Tag Search Tab -->
            <div id="tagsearch-tab" class="tab-content">
                <h3>Advanced POS & Semantic Tag Search</h3>
                
                <div class="tag-helper">
                    <h4>📖 Penn Treebank POS Tags (Click to insert)</h4>
                    <div class="tag-grid" id="posTagGrid"></div>
                </div>

                <div class="tag-helper" style="background:#ffe7e7; border-color:#dc3545;">
                    <h4 style="color:#721c24;">🔬 USAS Semantic Tags (PyMUSAS Categories)</h4>
                    <div class="tag-grid" id="semanticTagGrid"></div>
                </div>

                <div class="search-box">
                    <select id="tagSearchType">
                        <option value="pos">POS Tag Search</option>
                        <option value="semantic">Semantic Tag Search (USAS)</option>
                    </select>
                    <input type="text" id="tagSearchQuery" placeholder="Enter tag (e.g., VBZ, NN, Z1, A5.1+)...">
                    <label>Context:</label>
                    <input type="number" id="tagSearchWindow" value="5" min="1" max="20" style="max-width:100px;">
                    <button class="button" onclick="performTagSearch()">🏷️ Search</button>
                    <button class="button button-success" onclick="exportToExcel('tags')">📊 Export Excel</button>
                </div>

                <div class="info-box">
                    <p><strong>💡 Pro Tip:</strong> Use wildcard patterns like VB* to match VB, VBZ, VBG, VBD, etc.</p>
                </div>

                <div id="tagSearchResults" class="analysis-output"></div>
            </div>

            <!-- Frequency Tab -->
            <div id="frequency-tab" class="tab-content">
                <h3>Word Frequency Analysis</h3>
                <div class="search-box">
                    <select id="freqType">
                        <option value="word">Word Forms</option>
                        <option value="lemma">Lemmas</option>
                        <option value="pos">POS Tags</option>
                    </select>
                    <input type="number" id="freqLimit" value="50" min="10" max="500" placeholder="Top N">
                </div>
                <button class="button" onclick="generateFrequency()">📊 Generate</button>
                <button class="button button-success" onclick="exportToExcel('frequency')">📊 Export Excel</button>
                <div id="frequencyResults" class="analysis-output"></div>
            </div>

            <!-- Collocation Tab -->
            <div id="collocation-tab" class="tab-content">
                <h3>Collocation Analysis</h3>
                <div class="search-box">
                    <input type="text" id="collocSearch" placeholder="Node word...">
                    <input type="number" id="collocWindow" value="5" min="1" max="10" placeholder="Window" style="max-width:100px;">
                    <button class="button" onclick="analyzeCollocations()">🔗 Analyze</button>
                    <button class="button button-success" onclick="exportToExcel('collocation')">📊 Export Excel</button>
                </div>
                <div id="collocationResults" class="analysis-output"></div>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div id="corpusModal" class="modal">
        <div class="modal-content">
            <h3>Name Your Corpus</h3>
            <input type="text" id="corpusName" placeholder="Enter corpus name...">
            <div style="margin-top:20px;">
                <button class="button" onclick="saveCorpus()">Save</button>
                <button class="button button-secondary" onclick="closeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div id="processingOverlay" class="processing-overlay">
        <div class="processing-content">
            <div class="spinner-large"></div>
            <h3 id="processingTitle">Processing...</h3>
            <p id="processingSubtitle">Please wait</p>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width:0%;">0%</div>
            </div>
        </div>
    </div>

    <script>
        // Initialize
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        let corpora = [];
        let currentCorpus = null;
        let processedData = null;

        // Penn Treebank POS Tags
        const POS_TAGS = {
            'CC': 'Coordinating conjunction',
            'CD': 'Cardinal number',
            'DT': 'Determiner',
            'EX': 'Existential there',
            'FW': 'Foreign word',
            'IN': 'Preposition/subordinating conjunction',
            'JJ': 'Adjective',
            'JJR': 'Adjective, comparative',
            'JJS': 'Adjective, superlative',
            'LS': 'List item marker',
            'MD': 'Modal',
            'NN': 'Noun, singular',
            'NNS': 'Noun, plural',
            'NNP': 'Proper noun, singular',
            'NNPS': 'Proper noun, plural',
            'PDT': 'Predeterminer',
            'POS': 'Possessive ending',
            'PRP': 'Personal pronoun',
            'PRP$': 'Possessive pronoun',
            'RB': 'Adverb',
            'RBR': 'Adverb, comparative',
            'RBS': 'Adverb, superlative',
            'RP': 'Particle',
            'SYM': 'Symbol',
            'TO': 'to',
            'UH': 'Interjection',
            'VB': 'Verb, base form',
            'VBD': 'Verb, past tense',
            'VBG': 'Verb, gerund/present participle',
            'VBN': 'Verb, past participle',
            'VBP': 'Verb, non-3rd person singular present',
            'VBZ': 'Verb, 3rd person singular present',
            'WDT': 'Wh-determiner',
            'WP': 'Wh-pronoun',
            'WP$': 'Possessive wh-pronoun',
            'WRB': 'Wh-adverb'
        };

        // USAS Semantic Tags (Simplified)
        const SEMANTIC_TAGS = {
            'A': 'General & abstract terms',
            'A1': 'General',
            'A5.1+': 'Evaluation: Good',
            'A5.1-': 'Evaluation: Bad',
            'B': 'The body & the individual',
            'B1': 'Anatomy & physiology',
            'E': 'Emotion',
            'E1': 'General',
            'E2+': 'Like',
            'E2-': 'Dislike',
            'I': 'Money & commerce',
            'I1': 'Money',
            'I2': 'Business',
            'M': 'Movement, location',
            'M1': 'Moving, coming & going',
            'M2': 'Putting, pulling, pushing',
            'N': 'Numbers & measurement',
            'N1': 'Numbers',
            'N3': 'Measurement',
            'Q': 'Language & communication',
            'Q1': 'Communication',
            'Q2': 'Speech acts',
            'S': 'Social actions, states',
            'S1': 'Social actions',
            'S2': 'People',
            'T': 'Time',
            'T1': 'Time: General',
            'T2': 'Time: Beginning & ending',
            'X': 'Psychological actions',
            'X1': 'General',
            'X2': 'Mental actions & processes',
            'Z': 'Names & grammatical words',
            'Z1': 'Personal names',
            'Z2': 'Geographical names',
            'Z3': 'Other proper names',
            'Z4': 'Discourse Bin',
            'Z5': 'Grammatical bin',
            'Z8': 'Pronouns',
            'Z99': 'Unmatched'
        };

        // Initialize tag grids
        function initializeTagGrids() {
            const posGrid = document.getElementById('posTagGrid');
            const semGrid = document.getElementById('semanticTagGrid');

            posGrid.innerHTML = Object.entries(POS_TAGS).map(([tag, desc]) => `
                <div class="tag-button" onclick="insertTag('${tag}', 'pos')">
                    <strong>${tag}</strong>
                    <small>${desc}</small>
                </div>
            `).join('');

            semGrid.innerHTML = Object.entries(SEMANTIC_TAGS).map(([tag, desc]) => `
                <div class="tag-button" onclick="insertTag('${tag}', 'semantic')">
                    <strong>${tag}</strong>
                    <small>${desc}</small>
                </div>
            `).join('');
        }

        function insertTag(tag, type) {
            document.getElementById('tagSearchType').value = type;
            document.getElementById('tagSearchQuery').value = tag;
        }

        // Enhanced POS tagging with Penn Treebank tags
        function enhancedPOSTag(word, prevWord) {
            const lower = word.toLowerCase();
            
            // Determiners
            if (['the', 'a', 'an'].includes(lower)) return 'DT';
            if (['this', 'that', 'these', 'those'].includes(lower)) return 'DT';
            
            // Pronouns
            if (['i', 'you', 'he', 'she', 'it', 'we', 'they'].includes(lower)) return 'PRP';
            if (['my', 'your', 'his', 'her', 'its', 'our', 'their'].includes(lower)) return 'PRP$';
            
            // Verbs
            if (['is', 'am', 'are', 'was', 'were', 'be', 'been', 'being'].includes(lower)) return 'VBZ';
            if (lower.endsWith('ing')) return 'VBG';
            if (lower.endsWith('ed')) return 'VBD';
            if (['have', 'has', 'had'].includes(lower)) return 'VBP';
            
            // Modals
            if (['can', 'could', 'may', 'might', 'must', 'shall', 'should', 'will', 'would'].includes(lower)) return 'MD';
            
            // Prepositions
            if (['in', 'on', 'at', 'to', 'for', 'with', 'by', 'from', 'of', 'about', 'into', 'through'].includes(lower)) return 'IN';
            
            // Conjunctions
            if (['and', 'but', 'or', 'nor', 'yet', 'so'].includes(lower)) return 'CC';
            
            // Adverbs
            if (lower.endsWith('ly')) return 'RB';
            if (['very', 'really', 'quite', 'too', 'also', 'just'].includes(lower)) return 'RB';
            
            // Adjectives
            if (lower.endsWith('ive') || lower.endsWith('ous') || lower.endsWith('ful') || lower.endsWith('less')) return 'JJ';
            if (lower.endsWith('er') && word.length > 4) return 'JJR';
            if (lower.endsWith('est') && word.length > 4) return 'JJS';
            
            // Numbers
            if (/^\d+$/.test(word)) return 'CD';
            
            // Proper nouns
            if (/^[A-Z]/.test(word) && word.length > 1) return 'NNP';
            
            // Plural nouns
            if (lower.endsWith('s') && word.length > 2 && !lower.endsWith('ss')) return 'NNS';
            
            // Default noun
            return 'NN';
        }

        function basicLemmatize(word) {
            const lower = word.toLowerCase();
            if (lower.endsWith('ies') && lower.length > 4) return lower.slice(0, -3) + 'y';
            if (lower.endsWith('es') && !lower.endsWith('ses')) return lower.slice(0, -2);
            if (lower.endsWith('s') && !lower.endsWith('ss') && lower.length > 2) return lower.slice(0, -1);
            if (lower.endsWith('ing') && lower.length > 4) return lower.slice(0, -3);
            if (lower.endsWith('ed') && lower.length > 3) return lower.slice(0, -2);
            return lower;
        }

        // Semantic tagging simulation
        function assignSemanticTag(word, pos) {
            const lower = word.toLowerCase();
            
            // Common semantic categories
            if (['i', 'you', 'he', 'she', 'we', 'they', 'him', 'her', 'them'].includes(lower)) return 'Z8';
            if (['the', 'a', 'an', 'this', 'that', 'and', 'or', 'but'].includes(lower)) return 'Z5';
            if (['very', 'really', 'quite'].includes(lower)) return 'A13.3';
            if (['good', 'great', 'excellent', 'wonderful', 'amazing'].includes(lower)) return 'A5.1+';
            if (['bad', 'terrible', 'awful', 'poor'].includes(lower)) return 'A5.1-';
            if (['love', 'like', 'enjoy'].includes(lower)) return 'E2+';
            if (['hate', 'dislike'].includes(lower)) return 'E2-';
            if (['money', 'dollar', 'pound', 'euro'].includes(lower)) return 'I1';
            if (['time', 'hour', 'minute', 'second', 'day', 'year'].includes(lower)) return 'T1';
            if (['think', 'believe', 'know', 'understand'].includes(lower)) return 'X2.1';
            if (['say', 'tell', 'speak', 'talk'].includes(lower)) return 'Q2.1';
            if (['go', 'come', 'move', 'walk', 'run'].includes(lower)) return 'M1';
            if (['people', 'person', 'man', 'woman'].includes(lower)) return 'S2';
            
            // Numbers
            if (/^\d+$/.test(word)) return 'N1';
            
            // Default based on POS
            if (pos.startsWith('NN')) return 'A3';  // General nouns
            if (pos.startsWith('VB')) return 'A3';  // General verbs
            if (pos.startsWith('JJ')) return 'A3';  // General adjectives
            
            return 'Z99';  // Unmatched
        }

        // Chunked processing for large files
        function tokenizeChunked(text, chunkSize = 1000) {
            const words = text.match(/\b[\w']+\b|[^\w\s]/g) || [];
            const tokens = [];
            let sentenceIndex = 0;
            let globalIndex = 0;

            for (let i = 0; i < words.length; i++) {
                const word = words[i];
                const prevWord = i > 0 ? words[i - 1] : '';
                
                if (word.trim()) {
                    const pos = enhancedPOSTag(word, prevWord);
                    const semantic = assignSemanticTag(word, pos);
                    
                    tokens.push({
                        text: word,
                        lemma: basicLemmatize(word),
                        pos: pos,
                        semantic: semantic,
                        sentence: sentenceIndex,
                        index: globalIndex++
                    });
                }

                // Detect sentence boundaries
                if (['.', '!', '?'].includes(word)) {
                    sentenceIndex++;
                }
            }

            return tokens;
        }

        async function processText() {
            const text = document.getElementById('textInput').value.trim();
            if (!text) {
                alert('Please enter some text first!');
                return;
            }

            showProcessing('Processing text...', 'Tokenizing and tagging...');

            setTimeout(() => {
                try {
                    updateProgress(20);
                    const tokens = tokenizeChunked(text);
                    
                    updateProgress(80);
                    processedData = {
                        text: text,
                        tokens: tokens,
                        sentences: [...new Set(tokens.map(t => t.sentence))].length
                    };

                    updateProgress(100);
                    hideProcessing();
                    document.getElementById('corpusModal').classList.add('show');
                } catch (error) {
                    hideProcessing();
                    alert('Error processing text: ' + error.message);
                }
            }, 100);
        }

        async function handlePDFUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            showProcessing('Loading PDF...', `Processing: ${file.name}`);

            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
                
                updateProgress(10);
                updateProcessing('Extracting text...', `${pdf.numPages} pages found`);

                let fullText = '';
                const progressPerPage = 70 / pdf.numPages;

                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    fullText += pageText + '\n\n';
                    
                    updateProgress(10 + (i * progressPerPage));
                    updateProcessing('Extracting text...', `Page ${i} of ${pdf.numPages}`);
                }

                updateProgress(80);
                updateProcessing('Finalizing...', 'Preparing text...');

                document.getElementById('textInput').value = fullText;
                
                updateProgress(100);
                hideProcessing();
                
                alert(`✅ PDF loaded successfully!\n\n📄 Pages: ${pdf.numPages}\n📝 Characters: ${fullText.length.toLocaleString()}\n\nClick "Process Text" to analyze.`);

            } catch (error) {
                hideProcessing();
                console.error('PDF error:', error);
                alert('Error loading PDF: ' + error.message);
            }
        }

        function saveCorpus() {
            const name = document.getElementById('corpusName').value.trim();
            if (!name) {
                alert('Please enter a corpus name!');
                return;
            }

            const corpus = {
                id: Date.now(),
                name: name,
                data: processedData,
                wordCount: processedData.tokens.length,
                sentences: processedData.sentences,
                created: new Date().toLocaleString()
            };

            corpora.push(corpus);
            currentCorpus = corpus;

            updateCorpusList();
            closeModal();

            alert(`✅ Corpus "${name}" saved!\n\n📊 ${corpus.wordCount.toLocaleString()} tokens\n📄 ${corpus.sentences} sentences`);
        }

        function updateCorpusList() {
            const list = document.getElementById('corpusList');
            const stats = document.getElementById('corpusStats');
            
            if (corpora.length === 0) {
                list.innerHTML = '<p style="color:#6c757d;">No corpora yet. Process some text to get started!</p>';
                stats.innerHTML = '';
                return;
            }

            const totalTokens = corpora.reduce((sum, c) => sum + c.wordCount, 0);
            const totalSentences = corpora.reduce((sum, c) => sum + c.sentences, 0);

            stats.innerHTML = `
                <div class="stat-card">
                    <h4>${corpora.length}</h4>
                    <p>Total Corpora</p>
                </div>
                <div class="stat-card">
                    <h4>${totalTokens.toLocaleString()}</h4>
                    <p>Total Tokens</p>
                </div>
                <div class="stat-card">
                    <h4>${totalSentences.toLocaleString()}</h4>
                    <p>Total Sentences</p>
                </div>
            `;

            list.innerHTML = corpora.map(c => `
                <div class="corpus-item ${currentCorpus && currentCorpus.id === c.id ? 'active' : ''}" onclick="selectCorpus(${c.id})">
                    <h4>${c.name}</h4>
                    <p>📝 ${c.wordCount.toLocaleString()} tokens</p>
                    <p>📄 ${c.sentences.toLocaleString()} sentences</p>
                    <p>🕐 ${c.created}</p>
                    <button class="button button-secondary" style="margin-top:10px; padding:8px 16px;" onclick="event.stopPropagation(); deleteCorpus(${c.id})">🗑️ Delete</button>
                </div>
            `).join('');
        }

        function selectCorpus(id) {
            currentCorpus = corpora.find(c => c.id === id);
            updateCorpusList();
            alert('✅ Selected: ' + currentCorpus.name);
        }

        function deleteCorpus(id) {
            if (confirm('Delete this corpus?')) {
                corpora = corpora.filter(c => c.id !== id);
                if (currentCorpus && currentCorpus.id === id) {
                    currentCorpus = corpora[0] || null;
                }
                updateCorpusList();
            }
        }

        function clearAllCorpora() {
            if (confirm('Delete ALL corpora?')) {
                corpora = [];
                currentCorpus = null;
                updateCorpusList();
            }
        }

        function performKWIC() {
            if (!currentCorpus) {
                alert('Please select a corpus first!');
                return;
            }

            const searchTerm = document.getElementById('kwicSearch').value.toLowerCase();
            const windowSize = parseInt(document.getElementById('kwicWindow').value) || 5;

            if (!searchTerm) {
                alert('Please enter a search term!');
                return;
            }

            const tokens = currentCorpus.data.tokens;
            const results = [];

            tokens.forEach((token, i) => {
                if (token.text.toLowerCase().includes(searchTerm) || token.lemma.includes(searchTerm)) {
                    const left = tokens.slice(Math.max(0, i - windowSize), i).map(t => t.text).join(' ');
                    const right = tokens.slice(i + 1, Math.min(tokens.length, i + windowSize + 1)).map(t => t.text).join(' ');

                    results.push({
                        num: results.length + 1,
                        filename: currentCorpus.name,
                        left: left,
                        node: token.text,
                        right: right
                    });
                }
            });

            displayKWIC(results);
        }

        function displayKWIC(results) {
            const container = document.getElementById('kwicResults');

            if (results.length === 0) {
                container.innerHTML = '<p>No matches found.</p>';
                return;
            }

            container.innerHTML = `
                <p><strong>Found ${results.length.toLocaleString()} matches</strong></p>
                <table class="kwic-table">
                    <thead>
                        <tr>
                            <th>Number</th>
                            <th>File Name</th>
                            <th style="width:30%;">Left Context</th>
                            <th>Node</th>
                            <th style="width:30%;">Right Context</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${results.map(r => `
                            <tr>
                                <td>${r.num}</td>
                                <td>${r.filename}</td>
                                <td class="left-context">${r.left}</td>
                                <td class="node">${r.node}</td>
                                <td class="right-context">${r.right}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;

            window.currentResults = { type: 'kwic', data: results };
        }

        function performTagSearch() {
            if (!currentCorpus) {
                alert('Please select a corpus first!');
                return;
            }

            const searchType = document.getElementById('tagSearchType').value;
            const query = document.getElementById('tagSearchQuery').value.toUpperCase();
            const windowSize = parseInt(document.getElementById('tagSearchWindow').value) || 5;

            if (!query) {
                alert('Please enter a tag query!');
                return;
            }

            const tokens = currentCorpus.data.tokens;
            const results = [];
            const isWildcard = query.includes('*');

            tokens.forEach((token, i) => {
                let match = false;

                if (searchType === 'pos') {
                    if (isWildcard) {
                        const pattern = query.replace('*', '.*');
                        const regex = new RegExp('^' + pattern + ');
                        match = regex.test(token.pos);
                    } else {
                        match = token.pos === query;
                    }
                } else if (searchType === 'semantic') {
                    if (isWildcard) {
                        const pattern = query.replace('*', '.*');
                        const regex = new RegExp('^' + pattern);
                        match = regex.test(token.semantic);
                    } else {
                        match = token.semantic.startsWith(query);
                    }
                }

                if (match) {
                    const left = tokens.slice(Math.max(0, i - windowSize), i).map(t => t.text).join(' ');
                    const right = tokens.slice(i + 1, Math.min(tokens.length, i + windowSize + 1)).map(t => t.text).join(' ');

                    results.push({
                        num: results.length + 1,
                        filename: currentCorpus.name,
                        left: left,
                        node: token.text,
                        right: right,
                        tag: searchType === 'pos' ? token.pos : token.semantic
                    });
                }
            });

            displayTagSearch(results, searchType);
        }

        function displayTagSearch(results, searchType) {
            const container = document.getElementById('tagSearchResults');

            if (results.length === 0) {
                container.innerHTML = '<p>No matches found.</p>';
                return;
            }

            container.innerHTML = `
                <p><strong>Found ${results.length.toLocaleString()} matches</strong></p>
                <table class="kwic-table">
                    <thead>
                        <tr>
                            <th>Number</th>
                            <th>File Name</th>
                            <th style="width:28%;">Left Context</th>
                            <th>Node</th>
                            <th style="width:28%;">Right Context</th>
                            <th>Tag</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${results.map(r => `
                            <tr>
                                <td>${r.num}</td>
                                <td>${r.filename}</td>
                                <td class="left-context">${r.left}</td>
                                <td class="node">${r.node}</td>
                                <td class="right-context">${r.right}</td>
                                <td><span class="tag tag-pos">${r.tag}</span></td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;

            window.currentResults = { type: 'tags', data: results };
        }

        function generateFrequency() {
            if (!currentCorpus) {
                alert('Please select a corpus first!');
                return;
            }

            const type = document.getElementById('freqType').value;
            const limit = parseInt(document.getElementById('freqLimit').value) || 50;

            const tokens = currentCorpus.data.tokens;
            const freq = {};

            tokens.forEach(token => {
                let key;
                if (type === 'word') key = token.text.toLowerCase();
                else if (type === 'lemma') key = token.lemma;
                else if (type === 'pos') key = token.pos;

                freq[key] = (freq[key] || 0) + 1;
            });

            const sorted = Object.entries(freq)
                .sort((a, b) => b[1] - a[1])
                .slice(0, limit);

            displayFrequency(sorted);
        }

        function displayFrequency(freq) {
            const container = document.getElementById('frequencyResults');

            container.innerHTML = `
                <p><strong>Top ${freq.length} items</strong></p>
                <table class="kwic-table">
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Item</th>
                            <th>Frequency</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${freq.map(([item, count], i) => `
                            <tr>
                                <td>${i + 1}</td>
                                <td><strong>${item}</strong></td>
                                <td>${count.toLocaleString()}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;

            window.currentResults = { type: 'frequency', data: freq };
        }

        function analyzeCollocations() {
            if (!currentCorpus) {
                alert('Please select a corpus first!');
                return;
            }

            const nodeWord = document.getElementById('collocSearch').value.toLowerCase();
            const windowSize = parseInt(document.getElementById('collocWindow').value) || 5;

            if (!nodeWord) {
                alert('Please enter a node word!');
                return;
            }

            const tokens = currentCorpus.data.tokens;
            const collocates = {};

            tokens.forEach((token, i) => {
                if (token.text.toLowerCase() === nodeWord || token.lemma === nodeWord) {
                    const start = Math.max(0, i - windowSize);
                    const end = Math.min(tokens.length, i + windowSize + 1);

                    for (let j = start; j < end; j++) {
                        if (j !== i && tokens[j].text.length > 1) {
                            const word = tokens[j].text.toLowerCase();
                            collocates[word] = (collocates[word] || 0) + 1;
                        }
                    }
                }
            });

            const sorted = Object.entries(collocates)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 50);

            displayCollocations(sorted);
        }

        function displayCollocations(collocates) {
            const container = document.getElementById('collocationResults');

            container.innerHTML = `
                <p><strong>Top ${collocates.length} collocates</strong></p>
                <table class="kwic-table">
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Collocate</th>
                            <th>Frequency</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${collocates.map(([word, count], i) => `
                            <tr>
                                <td>${i + 1}</td>
                                <td><strong>${word}</strong></td>
                                <td>${count.toLocaleString()}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;

            window.currentResults = { type: 'collocation', data: collocates };
        }

        function exportToExcel(type) {
            if (!window.currentResults || window.currentResults.type !== type) {
                alert('No results to export! Please run the analysis first.');
                return;
            }

            const data = window.currentResults.data;
            let worksheet;
            let filename;

            if (type === 'kwic' || type === 'tags') {
                const wsData = [
                    ['Number', 'File Name', 'Left Context', 'Node', 'Right Context']
                ];
                
                if (type === 'tags') {
                    wsData[0].push('Tag');
                }

                data.forEach(row => {
                    const rowData = [row.num, row.filename, row.left, row.node, row.right];
                    if (type === 'tags') rowData.push(row.tag);
                    wsData.push(rowData);
                });

                worksheet = XLSX.utils.aoa_to_sheet(wsData);
                filename = type === 'kwic' ? 'corbas_concordance.xlsx' : 'corbas_tag_search.xlsx';
            } else if (type === 'frequency') {
                const wsData = [['Rank', 'Item', 'Frequency']];
                data.forEach(([item, count], i) => {
                    wsData.push([i + 1, item, count]);
                });
                worksheet = XLSX.utils.aoa_to_sheet(wsData);
                filename = 'corbas_frequency.xlsx';
            } else if (type === 'collocation') {
                const wsData = [['Rank', 'Collocate', 'Frequency']];
                data.forEach(([word, count], i) => {
                    wsData.push([i + 1, word, count]);
                });
                worksheet = XLSX.utils.aoa_to_sheet(wsData);
                filename = 'corbas_collocations.xlsx';
            }

            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, worksheet, 'Results');
            XLSX.writeFile(workbook, filename);
        }

        function showProcessing(title, subtitle) {
            document.getElementById('processingTitle').textContent = title;
            document.getElementById('processingSubtitle').textContent = subtitle;
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('progressFill').textContent = '0%';
            document.getElementById('processingOverlay').classList.add('show');
        }

        function updateProcessing(title, subtitle) {
            document.getElementById('processingTitle').textContent = title;
            document.getElementById('processingSubtitle').textContent = subtitle;
        }

        function updateProgress(percent) {
            const fill = document.getElementById('progressFill');
            fill.style.width = percent + '%';
            fill.textContent = Math.round(percent) + '%';
        }

        function hideProcessing() {
            document.getElementById('processingOverlay').classList.remove('show');
        }

        function closeModal() {
            document.getElementById('corpusModal').classList.remove('show');
            document.getElementById('corpusName').value = '';
        }

        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');

            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(tabName + '-tab').classList.add('active');
        }

        // Drag and drop
        const fileUpload = document.getElementById('fileUpload');

        fileUpload.addEventListener('dragover', (e) => {
            e.preventDefault();
            fileUpload.style.borderColor = '#667eea';
            fileUpload.style.background = '#e7f1ff';
        });

        fileUpload.addEventListener('dragleave', () => {
            fileUpload.style.borderColor = '#dee2e6';
            fileUpload.style.background = '#f8f9fa';
        });

        fileUpload.addEventListener('drop', (e) => {
            e.preventDefault();
            fileUpload.style.borderColor = '#dee2e6';
            fileUpload.style.background = '#f8f9fa';

            const file = e.dataTransfer.files[0];
            if (file && file.type === 'application/pdf') {
                document.getElementById('pdfInput').files = e.dataTransfer.files;
                handlePDFUpload({target: {files: [file]}});
            }
        });

        // Initialize
        initializeTagGrids();
        updateCorpusList();
    </script>
</body>
</html>